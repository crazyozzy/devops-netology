# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
	- `cd` - это встроенная команда о чем нам сообщает команда type:
		```
		root@vagrant:/home/vagrant#  type cd
		cd is a shell builtin
		```
		Теоретически `cd` можно сделать внешней, но тогда она будет менять каталог не в текущей сессии терминала и нам придется вызывать новый экземпляр `bash` из каталога в который мы перешли, например:
		```
		root@vagrant:/home/vagrant# bash -c 'mkdir test && cd /home/vagrant/test && bash'
		root@vagrant:/home/vagrant/test#
		```
		Если вызвать не вызывать `bash`, то мы не перейдем в катало ни в текущей ни в новой сессии.
1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
	- Чтобы не порождать излишний процесс `wc` можно использовать ключ `-c` для `grep`. Использование ключа описано в разделе `General Output Control` на 73 строке `man grep`. Пример:
		```
		root@vagrant:~# grep daemon /var/log/syslog | wc -l
		161
		root@vagrant:~# grep -c daemon /var/log/syslog
		161
		```
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
	- Родительским процессом в моей ВМ является `/sbin/init`:
		```
		root@vagrant:~# ps -q 1 -au
		USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
		root           1  0.0  0.6 103184 12952 ?        Ss   09:35   0:06 /sbin/init
		```
1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
	- В своей сессии терминала я выполнил команду:
		```
		root@vagrant:~# ll /test 2> /dev/pts/1
		```
		Во второй открытой сесии терминала я получил вывод:
		```
		vagrant@vagrant:~$ ls: cannot access '/test': No such file or directory
		```
		Список открытых терминалов:
		```
		root@vagrant:~# who
		vagrant  pts/0        2022-01-21 19:37 (10.0.2.2)
		vagrant  pts/1        2022-01-22 11:59 (10.0.2.2)
		```
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
	- Да получится:
		```
		root@vagrant:~# cat < test.txt > test_out.txt
		```
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
	- У меня получилось вывести в мой PTY при перенаправлении в `/dev/tty`
		```
		root@vagrant:~# cat test.txt > /dev/tty
		some test string
		root@vagrant:~# who
		vagrant  pts/0        2022-01-21 19:37 (10.0.2.2)
		```
		Также при подключении к `tty` через консоль `VirtualBox` у меня получилось вывести на нее при перенаправлении в `/dev/tty1`.
1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
	- При выполнении команды `bash 5>&1` у меня открылась новая сессия терминала. Если выполнить команду `echo netology > /proc/$$/fd/5` в этой новой сессии, то на консоль выведется строка `netology`. Происходит это потому, что мы перенаправляем файловый дескриптор `5` в `stdout`:
		```
		root@vagrant:~# bash 5>&1
		root@vagrant:~# echo netology > /proc/$$/fd/5
		netology
		root@vagrant:~# ll /proc/$$/fd/
		total 0
		dr-x------ 2 root root  0 Jan 22 12:28 ./
		dr-xr-xr-x 9 root root  0 Jan 22 12:28 ../
		lrwx------ 1 root root 64 Jan 22 12:28 0 -> /dev/pts/0
		lrwx------ 1 root root 64 Jan 22 12:28 1 -> /dev/pts/0
		lrwx------ 1 root root 64 Jan 22 12:28 2 -> /dev/pts/0
		lrwx------ 1 root root 64 Jan 22 12:28 255 -> /dev/pts/0
		lrwx------ 1 root root 64 Jan 22 12:28 5 -> /dev/pts/0
		```
1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
	- У мен почилось составить следующую команду:
		```
		root@vagrant:~# ls -l . /test 2>&1 >/dev/pts/0 | grep -c 'No such file or directory'
		.:
		total 20
		-rw-r--r-- 1 root root  754 Jan 22 13:23 1
		-rw-r--r-- 1 root root    0 Jan 22 12:11 cat
		-rw-r--r-- 1 root root   30 Jan 22 12:37 grep
		drwxr-xr-x 3 root root 4096 Dec 19 22:42 snap
		-rw-r--r-- 1 root root   17 Jan 22 12:13 test_out.txt
		-rw-r--r-- 1 root root   17 Jan 22 12:05 test.txt
		1
		```
1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
	- Команда `cat /proc/$$/environ` вывод переменные окружения. Для вывода можно использовать команды `env` или `printenv`
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
	- По адресу `/proc/<PID>/cmdline` содержиться полная командная строка для процесса, если он не является зомби-процессом. В последнем случае в файле ничего нет. 224 строка `man proc`.
	- Этот файл содержит является символической содержащий актуальный путь к выполняемому файлу. Попытка открыть этот файл откроет фактически выполняемый. 277 строка `man proc`
1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
	- Мой процессор поддерживает версию 4.2:
		```
		root@vagrant:~# grep sse /proc/cpuinfo
		flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 sse4_2 hypervisor lahf_lm invpcid_single ibrs_enhanced fsgsbase invpcid md_clear flush_l1d arch_capabilities
		```
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.
	- Как я понял из гуглинга по умолчанию при подключении не создается tty, однако это поведение можно изменить добавив ключ `-t` (316 строка `man ssh`):
		```
		vagrant@vagrant:~$ ssh -t localhost 'tty'
		vagrant@localhost's password:
		/dev/pts/1
		Connection to localhost closed.
		```
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
	- У меня по умолчанию не стоял пакет `reptyr`, после установки воспользовался примером из [репозитория](https://github.com/nelhage/reptyr). При попытке применения получил ошибку (к сожалению не записал), которую решил редактированием файла `/etc/sysctl.d/10-ptrace.conf` и перезагрузкой.
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
	- Команда `tee` перенаправлят стандартный ввод в файл и на консоль. Первый вариант не работает по описанной в вопросе причине, а второй вариант с `sudo tee` срабатывает, потому что мы запускаем непосредственно записывающий в файл процесс с необходимыми правами.
